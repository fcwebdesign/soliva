import { NextRequest, NextResponse } from 'next/server';
import { readContent } from '@/lib/content';

export async function POST(request: NextRequest) {
  try {
    const { blockType, pageKey, context, existingBlocks, existingTitle, existingOfferings } = await request.json();
    
    const content = await readContent();
    
    // Contexte spÃ©cifique selon la page avec plus de dÃ©tails
    let pageContext = '';
    if (pageKey === 'studio') {
      const studioBlocks = content.studio?.blocks || [];
      const existingContent = studioBlocks.map(b => b.content).join(' ');
      pageContext = `Page: Studio crÃ©atif Soliva. ${content.studio?.hero?.title || 'Le studio'}. ${content.studio?.description || ''}. Contenu existant: ${existingContent}`;
    } else if (pageKey === 'work') {
      const projects = content.work?.projects || [];
      const projectTitles = projects.map(p => p.title).join(', ');
      pageContext = `Page: Nos rÃ©alisations. ${content.work?.hero?.title || 'Nos rÃ©alisations'}. ${content.work?.description || ''}. Projets: ${projectTitles}`;
    } else if (pageKey === 'blog') {
      const articles = content.blog?.articles || [];
      const articleTitles = articles.map(a => a.title).join(', ');
      pageContext = `Page: Le journal. ${content.blog?.hero?.title || 'Le journal'}. ${content.blog?.description || ''}. Articles: ${articleTitles}`;
    } else if (pageKey === 'contact') {
      pageContext = `Page: Contact. ${content.contact?.hero?.title || 'Contact'}. ${content.contact?.description || ''}. Sections: ${JSON.stringify(content.contact?.sections || {})}`;
    }

    // Analyser les blocs existants pour la cohÃ©rence
    let blocksContext = '';
    if (existingBlocks && existingBlocks.length > 0) {
      const h2Titles = existingBlocks.filter(b => b.type === 'h2').map(b => b.content);
      const contentBlocks = existingBlocks.filter(b => b.type === 'content').map(b => b.content);
      
      blocksContext = `Blocs existants - Titres H2: ${h2Titles.join(', ')}. Contenu: ${contentBlocks.join(' ')}`;
    }

    // Instructions spÃ©cifiques selon le type de bloc - style direct et professionnel
    let blockInstructions = '';
    switch (blockType) {
      case 'content':
        blockInstructions = `GÃ©nÃ¨re un paragraphe de contenu clair et direct (2-3 phrases).
        Ã‰vite les mÃ©taphores poÃ©tiques, les formulations vagues, et le jargon marketing.
        Utilise des faits concrets, des exemples pratiques, ou des bÃ©nÃ©fices tangibles.
        IMPORTANT: Le contenu doit Ãªtre cohÃ©rent avec le titre existant et les titres H2 existants.
        Si un titre existe, le contenu doit l'expliquer, le dÃ©velopper ou le complÃ©ter.
        Style: professionnel, direct, authentique.`;
        break;
      case 'h2':
        blockInstructions = `GÃ©nÃ¨re un titre H2 clair et impactant (3-6 mots).
        Ã‰vite les titres gÃ©nÃ©riques comme "Notre approche", "Nos services", "Qui nous sommes".
        Utilise des verbes d'action concrets ou des questions directes.
        IMPORTANT: Le titre doit Ãªtre cohÃ©rent avec le contenu existant.
        Style: direct, professionnel, mÃ©morable.`;
        break;
      case 'h3':
        blockInstructions = `GÃ©nÃ¨re un titre H3 prÃ©cis et descriptif (2-4 mots).
        Ã‰vite les titres vagues comme "Processus", "MÃ©thode", "RÃ©sultats".
        Utilise des termes concrets, des chiffres, ou des concepts spÃ©cifiques.
        IMPORTANT: Le titre doit s'intÃ©grer dans la structure existante.
        Style: prÃ©cis, informatif, professionnel.`;
        break;
      case 'services':
        // Si on a des services existants avec des titres, gÃ©nÃ©rer seulement les descriptions
        if (existingOfferings && existingOfferings.length > 0) {
          const serviceTitles = existingOfferings.map((offering: any, index: number) => 
            `${index + 1}. ${offering.title || 'Service sans titre'}`
          ).join('\n');
          
          blockInstructions = `GÃ©nÃ¨re UNIQUEMENT les descriptions pour les services existants au format JSON:
          {
            "offerings": [
              {
                "description": "Description pour le service 1"
              },
              {
                "description": "Description pour le service 2"
              }
            ]
          }
          
          Services existants:
          ${serviceTitles}
          
          RÃ¨gles pour les descriptions:
          - 2-3 phrases maximum par description
          - BÃ©nÃ©fices concrets et mesurables
          - Processus ou mÃ©thodologie spÃ©cifique
          - Ã‰vite le jargon marketing ("nous accompagnons", "expertise", "solutions sur-mesure")
          - Style direct et professionnel
          - CohÃ©rent avec le titre du service
          
          IMPORTANT: Retourne uniquement le JSON avec les descriptions, sans les titres ni icÃ´nes.`;
        } else {
          // Si pas de services existants, gÃ©nÃ©rer une section complÃ¨te
          blockInstructions = `GÃ©nÃ¨re une section complÃ¨te d'offres de service au format JSON:
          {
            "title": "Titre de la section (optionnel, 3-6 mots)",
            "offerings": [
              {
                "id": "unique-id-1",
                "title": "Titre service 1",
                "description": "Description service 1",
                "icon": "Emoji 1"
              },
              {
                "id": "unique-id-2", 
                "title": "Titre service 2",
                "description": "Description service 2",
                "icon": "Emoji 2"
              },
              {
                "id": "unique-id-3",
                "title": "Titre service 3", 
                "description": "Description service 3",
                "icon": "Emoji 3"
              }
            ]
          }
          
          RÃ¨gles:
          - 3-4 services maximum
          - Titres variÃ©s et spÃ©cifiques
          - Descriptions courtes et impactantes
          - IcÃ´nes cohÃ©rentes avec le service
          - Ã‰vite la rÃ©pÃ©tition entre services
          
          IMPORTANT: Retourne uniquement le JSON valide, sans explications.`;
        }
        break;
      default:
        blockInstructions = `GÃ©nÃ¨re du contenu clair et appropriÃ© pour ce type de bloc.`;
    }

    // DÃ©terminer le bon paramÃ¨tre selon le modÃ¨le
    const model = 'gpt-5'; // Retour Ã  GPT-5 avec la nouvelle configuration
    const isGpt5 = model.startsWith('gpt-5');
    const requestBody = {
      model: model,
      messages: [
        {
          role: 'system',
          content: `Tu es copywriter senior crÃ©atif spÃ©cialisÃ© dans la crÃ©ation de contenu web unique et mÃ©morable.

${blockInstructions}

RÃ¨gles de style:
- Ã‰vite absolument les clichÃ©s marketing ("nous accompagnons", "expertise", "solutions sur-mesure")
- Ã‰vite les mÃ©taphores poÃ©tiques et les formulations vagues
- Utilise des faits concrets, des exemples pratiques, des bÃ©nÃ©fices tangibles
- Phrases courtes et directes, pas de prose fleurie
- Ton professionnel et authentique, pas corporate

Contraintes:
- Contenu en franÃ§ais
- Style: professionnel, direct, authentique
- Phrases courtes et percutantes
- Sortie: seulement le contenu final, sans explications ni balises HTML`
        },
        {
          role: 'user',
          content: `Type de bloc: ${blockType}
Page: ${pageKey}
Contexte: ${pageContext}
Blocs existants: ${blocksContext || 'Aucun'}
${existingTitle ? `Titre existant: ${existingTitle}` : ''}
${blockType === 'services' && existingOfferings ? `Services existants: ${existingOfferings.map((offering: any, index: number) => `${index + 1}. ${offering.title || 'Service sans titre'}`).join(', ')}` : ''}
Contexte supplÃ©mentaire: ${context || 'Aucun'}
Timestamp: ${Date.now()}

GÃ©nÃ¨re du contenu professionnel et direct pour ce bloc. Le contenu doit Ãªtre cohÃ©rent avec les autres blocs existants. Ã‰vite toute rÃ©pÃ©tition.`
        }
      ],
    };

    // Utiliser le bon paramÃ¨tre selon le modÃ¨le
    if (isGpt5) {
      // GPT-5 : RÃ©duire drastiquement l'effort de raisonnement
      requestBody.max_completion_tokens = 300;
      requestBody.reasoning_effort = "minimal";
      console.log('ðŸ”§ Configuration GPT-5 pour bloc:', JSON.stringify(requestBody, null, 2));
    } else {
      requestBody.max_tokens = 200;
      requestBody.temperature = 0.7;
      console.log('ðŸ”§ Configuration GPT-4 pour bloc:', JSON.stringify(requestBody, null, 2));
    }

    console.log('ðŸš€ Envoi requÃªte OpenAI pour bloc:', blockType);
    const openaiResponse = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });
    
    console.log('ðŸ“¡ Statut rÃ©ponse OpenAI:', openaiResponse.status, openaiResponse.statusText);

    if (!openaiResponse.ok) {
      throw new Error(`OpenAI API error: ${openaiResponse.status}`);
    }

    const openaiData = await openaiResponse.json();
    console.log('OpenAI Response:', JSON.stringify(openaiData, null, 2));
    
    const suggestedContent = openaiData.choices?.[0]?.message?.content;

    if (!suggestedContent) {
      console.error('Pas de contenu dans la rÃ©ponse OpenAI:', openaiData);
      throw new Error('Pas de rÃ©ponse de l\'IA');
    }

    // Pour les blocs de service, parser le JSON retournÃ©
    if (blockType === 'services') {
      try {
        const parsedContent = JSON.parse(suggestedContent.trim());
        return NextResponse.json({
          suggestedContent: parsedContent
        });
      } catch (parseError) {
        console.error('Erreur parsing JSON pour bloc service:', parseError);
        // Retourner le contenu brut si le parsing Ã©choue
        return NextResponse.json({
          suggestedContent: suggestedContent.trim()
        });
      }
    }

    return NextResponse.json({
      suggestedContent: suggestedContent.trim()
    });

  } catch (error) {
    console.error('Erreur suggestion contenu bloc:', error);
    return NextResponse.json(
      { error: error.message || 'Erreur lors de la gÃ©nÃ©ration du contenu' },
      { status: 500 }
    );
  }
} 